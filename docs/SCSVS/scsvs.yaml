metadata:
  title: Smart Contract Security Verification Standard (SCSVS)
  remarks: The SCSVS is a comprehensive framework for securing smart contracts, with
    a focus on identifying vulnerabilities and mitigating risks in smart contract
    deployments.
  version: v0.0.1
groups:
- gid: SCSVS-ARCH
  index: 1
  title: Architecture, Design, and Threat Modeling
  description: This group focuses on the design and architecture of smart contracts,
    ensuring that they are secure by design and built with modularity, upgradability,
    and separation of concerns in mind. It emphasizes the importance of threat modeling
    to identify and mitigate risks early in the design phase.
  controls:
  - cid: SCSVS-ARCH-1
    objective: Ensure that smart contracts are designed with modularity and upgradability
      in mind.
    requirements:
    - rid: S1.1.A1
      tid: SCSTG-TEST-0005
      requirement: Verify that the contract is divided into modular components or
        contracts.
      testname: Verify modularity and upgradability.
      checklist:
      - Are the smart contracts using import statements to include other contracts
        and libraries?
      - Are functions within the contract logically separated and grouped into different
        contracts or libraries?
    - rid: S1.1.A2
      tid: SCSTG-TEST-0006
      requirement: Ensure that upgrade mechanisms are designed to allow secure and
        controlled updates.
      testname: Ensure secure and controlled updates.
      checklist:
      - Is the contract using a proxy pattern (e.g., Transparent Proxy or UUPS Proxy)
        for upgradability?
      - Are the upgradeTo or similar functions protected with onlyOwner or onlyAdmin
        modifiers?
      - Are there migration functions to safely transfer state variables to the new
        contract version?
    - rid: S1.1.A3
      tid: SCSTG-TEST-0006
      requirement: Check that module boundaries are clearly defined and that dependencies
        are managed.
      testname: Check module boundaries and dependencies.
      checklist:
      - Are interfaces and abstract contracts used to define boundaries between modules?
      - Are external calls to other modules made through well-defined interfaces?
    - rid: S1.1.A4
      tid: SCSTG-TEST-0006
      requirement: Ensure that changes to storage variable order or types between
        contract versions are managed to avoid storage collisions and data corruption.
      testname: Ensure changes to storage variables are managed.
      checklist:
      - Is there a well-documented storage layout for the contract?
      - Are storage variables added in storage gaps to avoid conflicts?
    - rid: S1.1.A5
      tid: SCSTG-TEST-0006
      requirement: Verify that critical privilege transfers are conducted in a two-step
        process to ensure secure and reliable privilege changes.
      testname: Verify critical privilege transfers.
      checklist:
      - Is there a two-step process for transferring ownership using transferOwnership
        and claimOwnership?
      - Are there events emitted for each step of the transfer process?
    - rid: S1.1.A6
      tid: SCSTG-TEST-0006
      requirement: Verify that the data location of parameters and return variables
        is correctly handled when overriding internal and public functions to avoid
        generating invalid code during virtual function calls.
      testname: Verify data location handling in function overrides.
      checklist:
      - Are memory and storage keywords correctly used for parameters and return variables
        in overridden functions?
      - Are there tests covering function overrides to ensure no invalid virtual function
        calls?
    - rid: S1.1.B1
      requirement: Verify that different functionalities are separated into distinct
        contracts or modules.
      testname: Verify separation of different functionalities.
      checklist:
      - Are the contracts modular with clearly defined responsibilities?
      - Is there a single responsibility per contract or module?
    - rid: S1.1.B2
      requirement: Ensure that each module has a single responsibility and minimal
        dependencies on other modules.
      testname: Ensure minimal dependencies between modules.
      checklist:
      - Are modules loosely coupled?
      - Is each module's responsibility clearly defined and limited?
    - rid: S1.1.B3
      requirement: Check for any cross-module dependencies that could lead to security
        risks.
      testname: Check for cross-module dependencies.
      checklist:
      - Are there dependencies that could introduce security vulnerabilities?
      - Is each module's responsibility clearly defined and limited?
    - rid: S1.1.B4
      requirement: Ensure that the protocol maintains consistent and reliable operation
        during the transfer of privileges, with considerations for various edge cases.
      testname: Ensure consistent operation during privilege transfers.
      checklist:
      - Are edge cases considered during privilege transfers?
      - Is there a fallback mechanism in case of transfer failure?
    - rid: S1.1.B5
      requirement: Verify that proxy contracts use the onlyInitializing modifier instead
        of initializer to ensure proper initialization.
      testname: Verify proxy contract initialization.
      checklist:
      - Are proxy contracts using the onlyInitializing modifier?
      - Is there a check to prevent re-initialization?
    - rid: S1.1.B6
      requirement: Verify that storage layouts between contract versions are consistent
        to prevent data corruption and unpredictable behavior.
      testname: Verify storage layout consistency.
      checklist:
      - Are storage layouts compatible across different contract versions?
      - Is there documentation for storage layout changes?
    - rid: S1.1.B7
      requirement: Ensure that immutable variables are consistent across implementations
        during proxy upgrades.
      testname: Ensure immutable variable consistency.
      checklist:
      - Are immutable variables properly defined and documented?
      - Is there a verification process for consistency across upgrades?
    - rid: S1.1.B8
      requirement: Verify that implementations of the same logic across different
        parts of the contract are consistent to avoid introducing errors or vulnerabilities.
      testname: Verify consistency in logic implementation.
      checklist:
      - Is logic implemented consistently across the contract?
      - Is there a review process for verifying consistency?
    - rid: S1.1.B9
      requirement: Ensure that ETH and WETH are handled separately with appropriate
        checks to avoid errors due to incorrect assumptions about exclusivity.
      testname: Ensure separate handling of ETH and WETH.
      checklist:
      - Are ETH and WETH treated as distinct entities?
      - Are there checks in place to handle ETH and WETH appropriately?
    - rid: S1.1.B10
      requirement: Verify that contracts with constructors are not used in a proxy
        setup, and initializer logic is used instead.
      testname: Verify proxy setup for contracts with constructors.
      checklist:
      - Are contracts designed without constructors for proxy setups?
      - Is initializer logic implemented and verified?
  - cid: SCSVS-ARCH-2
    objective: Ensure that smart contracts are designed with modularity and upgradability
      in mind.
    requirements:
    - rid: S1.2.A1
      requirement: Verify that an upgrade mechanism (e.g., proxy pattern) is implemented
        for the contract.
      testname: Verify implementation of upgrade mechanisms.
      checklist:
      - Is the contract using a well-known proxy pattern such as Transparent Proxy
        or UUPS Proxy?
      - Are there unit tests verifying the upgrade functionality?
      - Is the upgrade mechanism designed to be easily extensible for future upgrades?
    - rid: S1.2.A2
      requirement: Ensure that the upgrade process includes safeguards against unauthorized
        upgrades.
      testname: Ensure safeguards against unauthorized upgrades.
      checklist:
      - Is the upgradeTo function protected by onlyOwner or onlyAdmin modifiers?
      - Are access controls and ownership mechanisms properly tested and reviewed?
      - Are multi-signature wallets or other advanced access control mechanisms used
        for upgrade authorization?
    - rid: S1.2.A3
      requirement: Check that the upgrade mechanism is documented and reviewed for
        security.
      testname: Review and document the upgrade mechanism.
      checklist:
      - Is the upgrade mechanism thoroughly documented in the project documentation?
      - Has the upgrade mechanism undergone a formal security audit?
      - Are there guidelines and best practices documented for performing upgrades?
    - rid: S1.2.A4
      requirement: Verify that immutable variables are consistent across implementations
        during proxy upgrades to prevent misuse.
      testname: Verify consistency of immutable variables.
      checklist:
      - Are immutable variables defined and documented across all contract versions?
      - Is there a validation process to ensure consistency of immutable variables
        during upgrades?
      - Are there automated tests checking the state of immutable variables before
        and after upgrades?
    - rid: S1.2.A5
      requirement: Verify that selfdestruct and delegatecall in implementation contracts
        do not introduce vulnerabilities or unexpected behaviors in a proxy setup.
      testname: Verify use of selfdestruct and delegatecall in proxy setup.
      checklist:
      - Is there a review process for identifying and mitigating risks associated
        with selfdestruct and delegatecall?
      - Are there unit tests covering scenarios involving selfdestruct and delegatecall?
      - Is the use of selfdestruct and delegatecall documented and justified in the
        contract?
    - rid: S1.2.A6
      requirement: Verify that UUPSUpgradeable contracts are protected against vulnerabilities
        that may affect uninitialized implementation contracts, ensuring secure upgrade
        mechanisms.
      testname: Protect UUPSUpgradeable contracts.
      checklist:
      - Are UUPSUpgradeable contracts tested for initialization-related vulnerabilities?
      - Is there a mechanism to ensure that implementation contracts are properly
        initialized before use?
      - Are there security reviews focused on initialization and upgrade vulnerabilities
        in UUPSUpgradeable contracts?
    - rid: S1.2.B1
      requirement: Verify that deprecated contract versions are correctly marked and
        handled.
      testname: Verify handling of deprecated contract versions.
      checklist:
      - Are deprecated contract versions clearly marked with appropriate deprecation
        notices in the code and documentation?
      - Is there a mechanism to disable functionality in deprecated contracts while
        maintaining state integrity?
      - Are deprecated contracts archived and isolated from the main deployment pipeline
        to prevent accidental usage?
    - rid: S1.2.B2
      requirement: Ensure that access to deprecated versions is restricted or disabled.
      testname: Ensure restriction or disabling of access to deprecated versions.
      checklist:
      - Are access controls updated to restrict interactions with deprecated contract
        versions?
      - Is there a revocation process in place to revoke permissions or keys associated
        with deprecated contracts?
      - Are deprecated contracts audited to ensure no critical functions remain accessible
        post-deprecation?
    - rid: S1.2.B3
      requirement: Check that migration paths from deprecated versions to new versions
        are secure.
      testname: Check security of migration paths from deprecated versions.
      checklist:
      - Is there a documented and tested migration plan for transitioning from deprecated
        to new contract versions?
      - Are migration scripts and tools audited for security vulnerabilities that
        could compromise the migration process?
      - Is there a rollback mechanism in case the migration encounters issues, ensuring
        no loss of state or functionality?
  - cid: SCSVS-ARCH-3
    objective: Ensure that smart contracts are designed with modularity and upgradability
      in mind.
    requirements:
    - rid: S1.3.C1
      requirement: Verify that mitigations are implemented for high-priority risks.
      testname: Verify implementation of high-priority risk mitigations.
      checklist:
      - Are there specific mitigations in place for reentrancy attacks, such as the
        use of checks-effects-interactions pattern or reentrancy guards?
      - Are overflow and underflow checks implemented using SafeMath or Solidity's
        built-in overflow protection?
      - Are access controls and role-based permissions thoroughly tested to prevent
        unauthorized access?
    - rid: S1.3.C2
      requirement: Ensure that mitigation strategies are documented and tested.
      testname: Ensure documentation and testing of mitigation strategies.
      checklist:
      - Are all mitigation strategies documented with clear explanations of how they
        address specific vulnerabilities?
      - Are there unit and integration tests specifically designed to validate the
        effectiveness of each mitigation strategy?
      - Is there a process for continuously updating the documentation and tests as
        new threats and mitigations are identified?
    - rid: S1.3.C3
      requirement: Check that the effectiveness of implemented mitigations is reviewed
        and validated.
      testname: Review and validate effectiveness of implemented mitigations.
      checklist:
      - Are periodic security audits conducted to review and validate the effectiveness
        of implemented mitigations?
      - Are there automated tools and scripts in place to continuously monitor the
        security posture of the smart contracts?
      - Is there a feedback loop for integrating audit findings and monitoring results
        into the mitigation strategy?
    - rid: S1.3.G1
      requirement: Understanding Protocol Actors
      testname: Understanding Protocol Actors
      checklist:
      - Have all actors and their interactions within the protocol been clearly identified
        and documented?
      - Are the roles and permissions of each actor clearly defined and appropriate?
    - rid: S1.3.G1
      requirement: Function Overriding
      testname: Verify Function Overriding
      checklist:
      - Does the contract inherit functions from parent contracts?
      - Are functions that override parent contract functions explicitly marked with the
        override keyword?
    - rid: S1.3.G3
      requirement: Sybil Attack Protection
      testname: Verify Sybil Attack Protection
      checklist:
      - Is the protocol's quorum mechanism or rewarding system designed to resist Sybil
        attacks? Verify the criteria used for participation or rewards.
      - How does the contract ensure that actions or decisions are not unduly influenced
        by Sybil attacks?
      - Are there checks or balances in place to validate the legitimacy of addresses
        participating in quorum or rewarding mechanisms?
    - rid: S1.3.G4
      requirement: Initializer Front Running
      testname: Verify Front-Running Protection for Initializer
      checklist:
      - Does the contract use a factory pattern or other mechanism to prevent front-running
        of the initializer function?
      - Is the initializer function protected from being called by unauthorized parties
        immediately after deployment?
      - Have you implemented safeguards to ensure the initializer cannot be front-run
        to alter critical access controls?
- gid: SCSVS-CODE
  index: 2
  title: 'Policies, Procedures, and Code Management '
  description: TBD
  controls:
  - cid: SCSVS-CODE-1
    objective: TBD
    requirements:
    - rid: S2.1.A1
      tid: TBD
      requirement: Ensure that developers do not use outdated compiler versions and
        adhere to the latest compiler recommendations.
      testname: Ensure adherence to latest compiler recommendations.
      checklist:
      - Are the smart contracts compiled using the latest stable version of the Solidity
        compiler?
      - Are there automated checks in the CI/CD pipeline to enforce the use of specific
        compiler versions?
      - Is there documentation and enforcement of the project's policy on compiler
        versioning?
    - rid: S2.1.A2
      tid: TBD
      requirement: Verify that deprecated functions are not used in the code.
      testname: Verify non-usage of deprecated functions.
      checklist:
      - Are deprecated functions identified and removed from the codebase during code
        reviews?
      - Are automated static analysis tools used to detect the usage of deprecated
        functions?
      - Is there a process to update the codebase to replace deprecated functions
        with their recommended alternatives?
    - rid: S2.1.B1
      tid: TBD
      requirement: Verify that all smart contract code changes are reviewed by at
        least two independent developers with expertise in smart contract security
        before merging to the main branch.
      testname: Independent expert code review.
      checklist:
      - Are pull requests (PRs) for smart contract changes reviewed and approved by
        at least two developers with smart contract security expertise?
      - Is there documentation of the review process, including comments and approvals
        from the reviewers?
    - rid: S2.1.B2
      tid: TBD
      requirement: Ensure that code reviews of smart contracts involve automated static
        analysis tools specifically designed for smart contracts, and that all flagged
        issues are addressed or documented prior to merging.
      testname: Incorporate automated static analysis tools.
      checklist:
      - Are automated static analysis tools, such as MythX or Slither, integrated
        into the CI/CD pipeline for smart contract code reviews?
      - Are all issues flagged by these tools documented and resolved or justified
        before merging the code?
    - rid: S2.1.B3
      tid: TBD
      requirement: Check that the code review process for smart contracts includes
        a thorough analysis for vulnerabilities such as reentrancy attacks, integer
        overflows, and improper access control.
      testname: Thorough analysis for vulnerabilities.
      checklist:
      - Are code reviews checking for potential reentrancy vulnerabilities, such as
        unprotected external calls within functions?
      - Are integer overflow and underflow vulnerabilities being checked using SafeMath
        or Solidity's built-in overflow protection?
      - Is the code reviewed for proper access control mechanisms, ensuring that only
        authorized addresses can perform sensitive operations?
    - rid: S2.1.B4
      tid: TBD
      requirement: Verify that code reviews include adherence to smart contract development
        standards, such as the use of safe math libraries and secure design patterns.
      testname: Adherence to development standards.
      checklist:
      - Are smart contracts using SafeMath libraries for all arithmetic operations
        to prevent overflows and underflows?
      - Is the use of design patterns like checks-effects-interactions consistently
        applied to mitigate reentrancy attacks?
      - Are fallback and receive functions implemented securely, with proper checks
        to prevent misuse?
    - rid: S2.1.B5
      tid: TBD
      requirement: Ensure that code reviews incorporate a checklist of common smart
        contract vulnerabilities, and that each item on the list is addressed before
        code is approved.
      testname: Checklist for common vulnerabilities.
      checklist:
      - Is there a comprehensive checklist of common smart contract vulnerabilities
        (e.g., reentrancy, integer overflows, unchecked external calls) used during
        code reviews?
      - Are all items on the checklist reviewed and marked as addressed in the code
        review process?
      - Are the checklist and review process updated regularly to incorporate new
        vulnerabilities and best practices?
    - rid: S2.1.G1
      requirement: Inherited Function Implementation
      testname: Verify Inherited Function Implementation
      checklist:
      - Have all required functions specified by parent contracts been implemented in
        the derived contract?
      - Are there any missing implementations that could affect the functionality or purpose
        of inheritance?
      - Is the inherited contract’s behavior consistent with the parent contract’s expectations?
    - rid: S2.1.G2
      requirement: Interface Implementation
      testname: Verify Interface Implementation
      checklist:
      - Does the contract correctly implement all functions defined in the interface it
        adheres to?
      - Have you verified that the interface methods are fully implemented and operational?
      - Are there any discrepancies between the interface specification and the contract
        implementation?
    - rid: S2.1.G3
      requirement: Inheritance Order
      testname: Verify Correct Inheritance Order
      checklist:
      - Is the inheritance chain ordered from the most base-like contract to the most
        derived contract?
      - Have you verified that the inheritance order does not affect variable initialization
        or functionality?
      - Are there any issues with storage layout or state variable initialization due
        to incorrect inheritance order?
    - rid: S2.1.G4
      requirement: Using Initializable
      testname: Verify Initializable Usage
      checklist:
      - Does the contract use the onlyInitializing modifier if it is intended to be inherited?
      - Is the initializer modifier used appropriately and not exposed to inherited contracts?
      - Have you ensured that initialization is restricted correctly to avoid unauthorized
        access?        
- gid: SCSVS-GOV
  index: 3
  title: TBD
  description: TBD
  controls:
  - cid: SCSVS-GOV-1
    objective: TBD
    requirements:
    - rid: S3.1.G1
      requirement: Does the protocol prevent liquidations during operational pauses or
        interruptions?
      testname: Verify correct handling of operational pauses and liquidations.
      checklist:
      - Does the protocol prevent liquidations during operational pauses or interruptions?
      - Are there mechanisms to handle user intentions to increase collateral during such
        pauses?
      - How does the system manage collateral and liquidation processes during temporary
        pauses?
    - rid: S3.1.G2
      requirement: What specific procedures are in place for resuming liquidations after
        a pause?
      testname: Verify resumption of paused liquidations without issues.
      checklist:
      - What specific procedures are in place for resuming liquidations after a pause?
      - How is solvency monitored and maintained during and after a liquidation pause?
      - Are there mechanisms to ensure that resumed liquidations do not disrupt system
        stability?
    - rid: S3.1.G3
      requirement: Does the protocol provide adequate incentives for liquidators to address
        small positions?
      testname: Verify fair distribution of small position incentives.
      checklist:
      - Does the protocol provide adequate incentives for liquidators to address small
        positions?
      - How are incentives structured to ensure small positions are effectively managed?
      - Are there measures in place to prevent neglect of small liquidation opportunities?
    - rid: S3.1.G4
      requirement: Is accrued interest included in the Loan-to-Value (LTV) calculations?
      testname: Verify correct interest rate calculations in LTV computations.
      checklist:
      - Is accrued interest included in the Loan-to-Value (LTV) calculations?
      - How does the system ensure that interest is factored into credit evaluations accurately?
      - Are there checks to confirm that interest calculations do not affect LTV assessments?
    - rid: S3.1.G5
      requirement: Can the liquidation and repaying mechanisms be independently enabled
        or disabled?
      testname: Verify consistency in liquidation and repayment logic.
      checklist:
      - Can the liquidation and repaying mechanisms be independently enabled or disabled?
      - What controls are in place to ensure consistent operation of both mechanisms?
      - How does the protocol prevent operational discrepancies between liquidation and
        repaying functions?
    - rid: S3.1.G6
      requirement: Is there a mechanism to ensure that liquidation returns are consistent
        and predictable?
      testname: Verify accuracy of liquidation return calculations.
      checklist:
      - Is there a mechanism to ensure that liquidation returns are consistent and predictable?
      - How does the protocol handle discrepancies in liquidation returns?
      - What steps are taken to ensure that liquidators receive the expected returns?
    - rid: S3.1.G7 
      requirement: Can users be trapped in perpetual debt due to protocol conditions or
        system design?
      testname: Verify mitigation of perpetual debt risks.
      checklist:
      - Can users be trapped in perpetual debt due to protocol conditions or system design?
      - What safeguards are in place to prevent users from being unable to repay their
        loans?
      - How does the protocol address situations where repayment becomes unfeasible?
    - rid: S3.1.G8 
      requirement: Can an arbitrary exchange rate be set during the processing of queued
        withdrawals?
      testname: Verify prevention of arbitrary exchange rate settings in withdrawals.
      checklist:
      - Can an arbitrary exchange rate be set during the processing of queued withdrawals?
      - Does the protocol ensure that the exchange rate used during withdrawal matches
        the rate at the time of withdrawal request?
      - Are there safeguards to prevent manipulation of the exchange rate during withdrawal
        processing?
    - rid: S3.1.G9
      requirement: Can users extend another user’s time lock duration by stacking tokens
        on their behalf?
      testname: Verify security of time lock amplification.
      checklist:
      - Can users extend another user’s time lock duration by stacking tokens on their
        behalf?
      - If token stacking is possible, are there checks to prevent unintended extensions
        of time locks?
      - Are there controls to ensure that time locks cannot be manipulated through token
        stacking?
    - rid: S3.1.G10
      requirement: Can reward distribution be manipulated to delay or accelerate payouts?
      testname: Verify fairness of reward distribution mechanisms.
      checklist:
      - Can reward distribution be manipulated to delay or accelerate payouts?
      - If rewards are distributed, are there controls to ensure timely and correct distribution?
      - Are there mechanisms to prevent premature or delayed reward claims?
    - rid: S3.1.G11
      requirement: Does the updateRewards function get called appropriately before relevant
        operations?
      testname: Verify security of update rewards function.
      checklist:
      - Does the updateRewards function get called appropriately before relevant operations?
      - Can the reward update function be overlooked or missed in any use-case scenarios?
      - Are there checks to ensure that rewards are up-to-date in all relevant cases?
    - rid: S3.1.G12
      requirement: Does calling a function multiple times with smaller amounts produce
        the same contract state as calling it once with the aggregate amount?
      testname: Verify financial operation consistency.
      checklist:
      - Does calling a function multiple times with smaller amounts produce the same contract
        state as calling it once with the aggregate amount?
      - Are there inconsistencies or unintended discrepancies when performing financial
        operations in parts versus as a whole?
      - If variations exist, are they intentional and well-documented, or do they indicate
        potential issues?
    - rid: S3.1.G13
      requirement: What happens to protocol interactions if the AAVE protocol is paused?
      testname: Verify correct enforcement of AAVE protocol pauses.
      checklist:
      - What happens to protocol interactions if the AAVE protocol is paused?
      - Are there contingency plans or alternative mechanisms in place if AAVE is paused?
      - Does the protocol handle the paused state of AAVE without causing disruptions?
    - rid: S3.1.G14
      requirement: What mechanisms are in place to handle pools that become deprecated?
      testname: Verify removal of deprecated pools.
      checklist:
      - What mechanisms are in place to handle pools that become deprecated?
      - If a pool is deprecated, how does the protocol adjust or manage its operations?
      - Are there fallback strategies for deprecated pools to avoid service interruptions?
    - rid: S3.1.G15
      requirement: What are the rules or limitations when lending or borrowing assets
        within the same eMode category?
      testname: Verify correct classification of eMode category assets.
      checklist:
      - What are the rules or limitations when lending or borrowing assets within the
        same eMode category?
      - Does the protocol handle transactions involving assets in the same eMode category
        without issues?
      - Are there constraints in place for interacting with assets in the same eMode category?
    - rid: S3.1.G16
      requirement: Do flash loans impact the pool index, and if so, how is this managed?
      testname: Verify accuracy of flash loan pool index calculations.
      checklist:
      - Do flash loans impact the pool index, and if so, how is this managed?
      - Are there mechanisms to mitigate the effects of flash loans on the pool index?
      - How does the protocol address the maximum number of flash loans per block affecting
        the pool index?
    - rid: S3.1.G17
      requirement: Is slippage calculated on-chain?
      testname: Verify correct implementation of on-chain slippage calculations.
      checklist:
      - Is slippage calculated on-chain?
      - Can users specify the slippage parameter in the asset amount?
      - What measures are in place to ensure accurate slippage calculation?
    - rid: S3.1.G18
      requirement: Is the slippage parameter enforced at the last step before transferring
        funds to users?
      testname: Verify minimization of intermediate swap slippage.
      checklist:
      - Is the slippage parameter enforced at the last step before transferring funds
        to users?
      - How is slippage enforced during the final fund transfer step?
      - Does the system check the slippage parameter before completing transactions?
    - rid: S3.1.G19
      requirement: Is there a non-zero check for the denominator before division or modulo
        operations?
      testname: Verify enforcement of zero denominator checks.
      checklist:
      - Is there a non-zero check for the denominator before division or modulo operations?
      - How does the system handle division or modulo by zero in Yul/inline assembly?
      - What measures are in place to prevent division or modulo by zero?
    - rid: S3.1.G20
      requirement: Two Transaction Actions Frontrunning
      testname: Verify Two Transaction Actions Frontrunning
      checklist:
      - Are two-transaction actions designed with measures to prevent frontrunning? Verify
        if there are checks or locks between transactions.
      - How does the protocol ensure that critical two-step actions are not vulnerable
        to attack during the intermediary state?
      - Are there safeguards to prevent malicious actors from intervening between the
        two transactions?
    - rid: S3.1.G21
      requirement: Dust Transactions Reversion
      testname: Verify Dust Transactions Reversion
      checklist:
      - Can users front-run transactions with negligible amounts to cause reverts? Verify
        the contract’s handling of such scenarios.
      - Are there checks to prevent transactions with minimal amounts from impacting the
        contract's state or execution flow?
      - How does the contract manage or mitigate the effects of dust transactions on legitimate
        operations?
    - rid: S3.1.G22
      requirement: Unexpected Rewards
      testname: Verify Unexpected Rewards Handling
      checklist:
      - Are there additional rewards accruing for user deposited assets?
      - Does the protocol track and manage all potential rewards for user deposits?
      - Are users provided with clear methods to claim or manage unexpected rewards?
    - rid: S3.1.G23
      requirement: Token Pegging
      testname: Ensure Stability for Pegged Tokens
      checklist:
      - Are the protocol tokens pegged to any other asset?
      - Have you tested the protocol’s behavior when the pegged asset depegs?
    - rid: S3.1.G24
      requirement: Visibility Modifier
      testname: Verify Visibility Modifier
      checklist:
      - Is the visibility of each function limited to the strictest level necessary (private
        or internal)?
      - Are there any functions that are currently public or external but could be restricted
        to internal or private?
      - Does the contract expose any sensitive operations or state changes to external parties that should be restricted?
- cid: SCSVS-GOV-2
  objective: TBD
  requirements:
  - rid: S3.2.G1
    requirement: Verify ERC20 Compliance
    testname: Verify ERC20 Compliance
    checklist:
    - Are the token's transfer functions (transfer, transferFrom) fully compliant with
      the EIP20 standard, including returning a boolean flag and reverting on failure?
    - Are safe transfer functions (safeTransfer, safeTransferFrom) consistently used
      throughout the contract?
  - rid: S3.2.G2
    requirement: Verify Approval Race Condition
    testname: Verify Approval Race Condition
    checklist:
    - Is there a risk of race conditions in the approval process that could lead to
      unexpected fund loss for the signer?
    - Are there mechanisms in place to prevent double-spending or front-running attacks?
  - rid: S3.2.G3
    requirement: Verify Decimal Discrepancies
    testname: Verify Decimal Discrepancies
    checklist:
    - Could differences in the number of decimals between various ERC20 tokens lead
      to calculation or interpretation errors?
    - Are there any conversions or calculations that might be affected by differing
      decimal places?
  - rid: S3.2.G4
    requirement: Caller Checking
    testname: Verify Caller Checking
    checklist:
    - Does the function restrict calls to only externally owned accounts (EOA) or only
      contract addresses as intended?
    - Are there access control checks in place to differentiate between EOA and contract
      callers when required?
    - Has the protocol been reviewed to ensure it meets the intended caller requirements?
  - rid: S3.2.G5
    requirement: Verify Address Checks
    testname: Verify Address Checks
    checklist:
    - Does the token implement any forms of address whitelisting, blacklisting, or validation
      checks that could introduce issues?
    - Are there any hardcoded addresses in the contract that could pose security risks?
  - rid: S3.2.G6
    requirement: Verify Transfer Fees
    testname: Verify Transfer Fees
    checklist:
    - Does the token impose a fee on transfers, resulting in the receiver getting less
      than the specified amount?
    - How are transfer fees calculated and collected?
  - rid: S3.2.G7
    requirement: Verify ERC777 Compatibility
    testname: Verify ERC777 Compatibility
    checklist:
    - Can the token also function as an ERC777 token, which includes hooks that execute
      code before and after transfers, potentially leading to reentrancy attacks?
    - Are there safeguards in place to handle the hooks securely?
  - rid: S3.2.G8
    requirement: Verify Solmate's ERC20.safeTransferLib Usage
    testname: Verify Solmate's ERC20.safeTransferLib Usage
    checklist:
    - Does the protocol utilize Solmate's ERC20.safeTransferLib, which does not check
      for the existence of a contract and could be exploited for honeypot attacks?
    - Are there alternative libraries or methods that could enhance security?
  - rid: S3.2.G9
    requirement: Verify Zero Amount Transfers
    testname: Verify Zero Amount Transfers
    checklist:
    - What is the token's behavior when transferring a zero amount? Does it revert,
      and could this cause issues in certain integrations and operations?
    - Are there any edge cases related to zero-amount transfers?
  - rid: S3.2.G10
    requirement: Verify ERC2612 Implementation
    testname: Verify ERC2612 Implementation
    checklist:
    - Is the token an ERC2612 implementation, and is the DOMAIN_SEPARATOR() function
      properly implemented to avoid vulnerabilities?
    - How is the permit() function implemented, and are there any potential issues?
  - rid: S3.2.G11
    requirement: Verify Permit Function Replay Protection
    testname: Verify Permit Function Replay Protection
    checklist:
    - Does the permit() function have adequate replay protection, or could someone reuse
      a permit signature multiple times to authorize multiple transfers?
    - Is the nonces mapping updated correctly, and does the implementation properly
      prevent replays?
- cid: SCSVS-GOV-3
  objective: TBD
  requirements:
  - rid: S3.3.G1
    requirement: Token Donation Manipulation
    testname: Verify Token Donation Manipulation
    checklist:
    - Does the contract rely on balance or balanceOf for determining token balances
      or ownership? If so, are there safeguards against manipulation through token donations?
    - Are token balances verified against internal accounting records rather than solely
      using balanceOf?
    - Does the contract implement additional validation to ensure donated tokens do
      not alter accounting in unexpected ways?
  - rid: S3.3.G2
    requirement: On-Chain Slippage Manipulation
    testname: Detect On-Chain Slippage Manipulation
    checklist:
    - Is slippage calculated directly on-chain?
    - Can the slippage calculation be influenced or manipulated by attackers?
    - Is there a mechanism to allow users to specify slippage based on off-chain calculations?
  - rid: S3.3.G3
    requirement: Intermediate Slippage Enforcement
    testname: Ensure Slippage is Enforced at All Stages
    checklist:
    - Is the slippage parameter enforced at all stages of the swap process, including
      the final step?
    - Can users receive less than the specified minimum if the final step does not enforce
      slippage?
  - rid: S3.3.G4
    requirement: First Deposit Initialization
    testname: Verify Initial Deposit Behavior
    checklist:
    - Does the initial deposit set parameters or conditions for subsequent deposits?
    - Have you tested to ensure that the first deposit initializes parameters correctly?
  - rid: S3.3.G5
    requirement: Read-Only Reentrancy
    testname: Verify Read-Only Reentrancy
    checklist:
    - Are there view functions that could be reentered in a way that might return stale
      or inconsistent values?
    - Does the contract have measures to prevent reentrancy issues in view functions,
      such as extending reentrancy guards?
    - How does the protocol ensure that read-only functions do not lead to inconsistent
      state or unintended actions?
  - rid: S3.3.G6
    requirement: Flashloan Deposit-Withdraw Attack
    testname: Prevent Flashloan-Based Withdrawals
    checklist:
    - Is it possible to withdraw in the same transaction as the deposit?
    - Does the protocol have protections against flashloan-based deposit-harvest-withdraw cycles?
  - rid: S3.3.G7
    requirement: Liquidation During Price Drops
    testname: Ensure Liquidation Resilience in Volatile Markets
    checklist:
    - Does the liquidation mechanism include logic to handle extreme price drops effectively?
    - Is there a safeguard to ensure liquidation occurs even when price volatility is high?
    - How is the liquidation trigger threshold adjusted during rapid market downturns?
  - rid: S3.3.G8
    requirement: Position Liquidation Risk
    testname: Manage Risks in Liquidation Processes
    checklist:
    - Is there a mechanism to automatically trigger liquidation if a position's collateral
      falls below the required threshold?
    - Are there specific conditions that can prevent liquidation, and how are these
      managed?
    - How does the system handle outstanding loans when the collateral value drops significantly?
  - rid: S3.3.G9
    requirement: Self-Liquidation Profit Loopholes
    testname: Prevent Self-Liquidation Abuse
    checklist:
    - Is there validation to prevent users from exploiting self-liquidation for profit?
    - How are self-liquidation scenarios tested for potential vulnerabilities?
    - Are there limits or conditions imposed on self-liquidation to prevent abuse?
  - rid: S3.3.G10
    requirement: Parent Contract Visibility
    testname: Verify Parent Contract Visibility
    checklist:
    - Have you reviewed the visibility of functions in parent contracts to ensure they
      are appropriately exposed?
    - Are there any public or external functions in parent contracts that should be
      restricted or hidden in the derived contract?
    - Is the visibility of inherited functions aligned with the desired access levels?
  - rid: S3.3.G11
    requirement: Commit Reveal Scheme
    testname: Verify Commit Reveal Scheme
    checklist:
    - Does the protocol implement a commit-reveal scheme to protect against front-running?
      Verify the presence of both commit and reveal phases.
    - How does the protocol ensure that the commit-reveal pattern is followed to prevent
      adversaries from gaining insight into actions before they are finalized?
    - Are there mechanisms in place to ensure confidentiality and integrity of actions
      until the reveal phase?
  - rid: S3.3.G12
    requirement: Hardcoded Slippage
    testname: Ensure Dynamic Slippage Implementation
    checklist:
    - Is slippage implemented as a hardcoded value in the contract?
    - Have you ensured that slippage can be adjusted dynamically based on market conditions?
    - Is there functionality allowing users to specify slippage parameters based on
      their own calculations?
  - rid: S3.3.G13
    requirement: Deadline Protection
    testname: Validate Deadline Protection Mechanisms
    checklist:
    - Does the protocol implement deadline protection to prevent transactions from being
      manipulated?
    - Is there an option for users to set deadlines for their transactions?
    - Have you validated that transactions cannot be processed outside the specified
      deadline?
  - rid: S3.3.G14
    requirement: Reserve Validation
    testname: Ensure Proper Reserve Validation
    checklist:
    - Is there a validation check in place for protocol reserves?
    - Have you ensured that reserves are verified before being used or lent out?
    - Does the protocol include mechanisms to safeguard against reserve depletion?
  - rid: S3.3.G15
    requirement: Slippage Protection
    testname: Ensure Slippage Protection
    checklist:
    - Is there a mechanism to protect against excessive slippage in trades?
    - Can users specify their own slippage parameters to manage risk?
    - Are there safeguards to prevent losses from large price deviations?
  - rid: S3.3.G16
    requirement: Min Amount Out Calculation
    testname: Ensure Reliable Min Amount Out Calculation
    checklist:
    - Does the protocol calculate minAmountOut before executing swaps?
    - Is the source of rates for minAmountOut reliable and protected from manipulation?
    - Have you validated the minAmountOut logic to prevent unfavorable rates and potential vulnerabilities?

